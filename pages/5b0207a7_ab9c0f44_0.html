<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<style>
			body, table{font-family: Tahoma; font-size: 12pt}
			table{border-collapse: collapse; border: solid gray; border-width: 2px 0 2px 0;}
			th{border: 1px solid gray; padding: 4px; background-color: #DDD;}
			td{border: 1px solid gray; padding: 4px;}
			tr:nth-child(2n){background-color: #f8f8f8;}
		</style>
	</head>
	<body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; ">
		<div>
			<p class="MsoNormal" style="margin-left: 0cm; text-indent: 0px; mso-list: l0 level1 lfo1"><span style="color: rgb(68, 68, 68); font-family: Arial; "></span>
			</p>
			<div><span style="font-weight: bold; "><span style="font-size: 13.5pt">红警任务变量论</span></span><span style="font-size: small;">&nbsp; &nbsp;by &nbsp;傻妖妖（OPERATE）</span>
			</div>
			<div><span style="font-size: 12pt; line-height: 200%; ">
				<div>1、红警地图编辑器并不存在抽象数字变量的直接表达方式，均只能以抽象方式存在。
				</div>
				<div>2、抽象变量之间可以比较大小，但必须通过一定的过程进行抽象的信息转化。
				</div>
				<div>3、抽象变量可以以抽象的方式进行无上限累计，且可以以抽象的方式互相累加。
				</div>
				<div>4、实例变量可以以抽象方式转化为抽象变量，但其本身不能直接相互比较。
				</div>
				<div>5、实例变量的定义是：实例变量是地图编辑器可以直接衡量的事物。在游戏中所有的时刻，这种变量都可以直接在游戏中显示其数量。仅仅因为视野、所属方非玩家等原因而造成不能直接显示，但确实能够衡量的变量，也属于实例变量。
				</div>
				<div>6、抽象变量的定义是：地图编辑器不能直接衡量，而是人为制造的用于表达抽象概念的变量。抽象变量可以通过某种信息转化的方式表达为实例变量，但本身不是游戏内已经存在的可以衡量的变量。
				</div>
				<div>7、通过地图编辑器触发而导致的金钱、电力等的无上限累计，其实质也是抽象变量在抽象意义上转化后在实例变量中的表达，并不是严格意义上的实例变量自身的无上限累计。
				</div>
				<div><br />
				</div>
				<div>地图编辑器自身是不存在变量的概念的，变量这个概念是我们人工引入的。变量在任务中表示某个特定事物的数量，比如地图上雷达的总数量，玩家建造的某坦克数量。
				</div>
				<div>让我们来尝试解决以下问题：占领电脑10个建造场中的任意3个，则玩家胜利（不讨论占领后又被摧毁的问题，只要占领过就算）
				</div>
				<div>这个问题有两个笨办法：第一个是将10个建造场设定为特殊作战方，当损失建筑为3时则玩家胜利。这个办法是不好的，因为摧毁也算是损失建筑。
				</div>
				<div>第二个比较直观，给10个建造场分别设置10个变量，讨论所有可能，然后只要达成一种就胜利。但经过计算我们知道可能性为120种。如果要占领4个或者5个，那么可能性则为210种和252种，一般的任务触发不会超过100个，明显这样的方法也很不好。
				</div>
				<div>因此我们便需要动用到变量论了。
				</div>
				<div>现在我们假设，玩家已占领过的建造场数量为X。如何判断X=3呢？由于地图编辑器没有变量的概念，X=3只是一个抽象的信息而不能存在于地图编辑器的实例中，它不能直接进行比较。因此我们需要一定的信息转换。比如，X=3时，50X=150.我们知道防空炮耗电量为50。假设现在某作战方的电力为149，那么当这个作战方有三个防空炮时，它就停电。停电是地图编辑器中一个具体可以测算的概念。也就是说X=3时，A就停电，那么就说明玩家占领了3个建造场，玩家胜利了。因此我们可以为10个建造场分别关联上以下10个触发（所属方都是A）：
				</div>
				<div>1进入事件 参数为玩家
				</div>
				<div>125 在指定路径点建造建筑……路径点即你希望建造防空炮的10个地点（一般地图外任意地方都可以），类型是防空炮
				</div>
				<div>这样一来，每当玩家占领一个建造场后，A就会在某个特定地点建造一个防空炮。
				</div>
				<div>然后我们给A摆上一个苏联发电厂，令它稍稍破损，这样A的电力便略低于150.那么当A电力不足时，玩家胜利
				</div>
				<div><br />
				</div>
				<div>这样一来，我们就可以随时判断X是否大于3了。从以上例子我们可以知道，变量是可以通过一定信息转化来与特定数值比较大小的。
				</div>
				<div>那么变量之间能否比较大小呢？答案是可以的。但是累计过程必须是一样的。现在我们指定以下信息转化过程：玩家每占领一个建造场，A就派出一架坦克到指定地点。电脑每占领一个建造场，A就派出一架坦克到另一个指定地点。假设30分钟后游戏终止，比较双方谁占的建造场多，即可根据坦克数量来判断多少。这个累计过程中，坦克小队的类型、数量必须是一样的。我们为这些坦克增加攻击某个路径点的脚本，并在这两个路径点上摆放同类型的建筑。在30分钟计时完毕前，这两个路径点一直保持铁幕的状态。如此一来，30分钟后坦克就会摧毁这两个建筑，但是坦克多的一方一定摧毁得更快。根据两个建筑摧毁速度的快慢，可以比较两个变量的大小。但这其中，除了坦克数量以外，其他条件必须保持一致。
				</div>
				<div>我们再来进一步探究变量的功能。
				</div>
				<div>这里提出一个问题：变量是否可以无上限地累计呢？
				</div>
				<div>这取决于变量的内容。如果要累计的是实例变量（比如地图上的雷达，电力，某玩家持有的金钱，这是具体而且地图上已经有的东西），那么变量无法累计；但如果是抽象变量，地图上不存在的话（比如作战小队），便可以累计。
				</div>
				<div>为什么有些变量可以累计而有些不能呢？作者目前所想到的能够无上限累计变量的方法只有一个,就是利用电脑AI。假设每隔10秒电脑派出一辆天启坦克，玩家摧毁100辆天启坦克为胜利。那么，100辆就是一个较大的数字，一般来说，我们会将这个天启坦克的归属方改为一个特殊作战方，当该作战方被毁100数量的单位即胜利。然而如果我们将胜利条件修改为摧毁500个电脑单位，其中摧毁100辆天启坦克有援军的话，这招就没用了。
				</div>
				<div>利用AI的特性，我们可以做到无上限累计变量。我们知道，假设AI的建造场数量为N，那么当我们摧毁一个防空炮且这个防空炮有节点时，AI会重建N个防空炮。如果n=2，那么每摧毁一辆天启坦克，电脑就会增加一个防空炮。当防空炮数量达到101时，玩家就赢了。同样这也能说明实例变量没有办法在非抽象意义上无上限累计的原因：无法像小队那样重复地关联着一个触发。
				</div>
				<div>有人可能会说，我可以用触发无上限建造电厂、或者无限加钱，这不是实例变量的无上限累计吗？首先要明确的是，当你在用触发无上限累计某个实例变量的时候，这已经是抽象意义上的信息转化过程了，是实例变量在抽象意义上的累计。
				</div>
				<div><br />
				</div>
				<div>此外，我们还有一个推论：地图编辑器可以做到有限个变量的累计。此外，地图编辑器可以判断一切有限元一次不等式是否成立。这是因为变量是可以累加的。我们在前面已经知道了变量之间的大小比较方法。比如，把电脑改成两个，玩家一个，假设玩家占领A个建造场，电脑两方分别占领B、C个建造场。那么我们需要比较A&gt;=B+C是否成立。因此易知，只要C的坦克加到B上面，与B执行一样的脚本即可。同样，如果是A&gt;=B+2C，则只需把C的特遣部队改成2架坦克就行了。
				</div>
				<div><br />
				</div></span>
			</div>
			<p>
			</p>
		</div>
	</body>
</html>